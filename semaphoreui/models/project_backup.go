// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ProjectBackup project backup
// Example: {"environments":[{"env":null,"json":"{}","name":"Empty","password":null}],"inventories":[{"become_key":"None","inventory":"","name":"Build","ssh_key":"None","type":"static"},{"become_key":"None","inventory":"","name":"Dev","ssh_key":"None","type":"file"},{"become_key":"None","inventory":"","name":"Prod","ssh_key":"None","type":"file"}],"keys":[{"name":"None","type":"none"},{"name":"Vault Password","type":"login_password"}],"meta":{"alert":true,"alert_chat":"Test","max_parallel_tasks":0,"name":"homelab","type":null},"repositories":[{"git_branch":"main","git_url":"https://github.com/semaphoreui/demo-project.git","name":"Demo","ssh_key":"None"}],"templates":[{"allow_override_args_in_task":false,"arguments":"[]","autorun":false,"build_template":null,"cron":"* * * * *","description":"Build Job","environment":"Empty","inventory":"Build","name":"Build","playbook":"build.yml","repository":"Demo","start_version":"1.0.0","suppress_success_alerts":false,"survey_vars":[],"type":"build","vault_key":null,"view":"Build"}],"views":[{"position":0,"title":"Build"}]}
//
// swagger:model ProjectBackup
type ProjectBackup struct {

	// environments
	Environments []*ProjectBackupEnvironmentsItems0 `json:"environments"`

	// inventories
	Inventories []*ProjectBackupInventoriesItems0 `json:"inventories"`

	// keys
	Keys []*ProjectBackupKeysItems0 `json:"keys"`

	// meta
	Meta *ProjectBackupMeta `json:"meta,omitempty"`

	// repositories
	Repositories []*ProjectBackupRepositoriesItems0 `json:"repositories"`

	// templates
	Templates []*ProjectBackupTemplatesItems0 `json:"templates"`

	// views
	Views []*ProjectBackupViewsItems0 `json:"views"`
}

// Validate validates this project backup
func (m *ProjectBackup) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEnvironments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInventories(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKeys(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMeta(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRepositories(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTemplates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateViews(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProjectBackup) validateEnvironments(formats strfmt.Registry) error {
	if swag.IsZero(m.Environments) { // not required
		return nil
	}

	for i := 0; i < len(m.Environments); i++ {
		if swag.IsZero(m.Environments[i]) { // not required
			continue
		}

		if m.Environments[i] != nil {
			if err := m.Environments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("environments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("environments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProjectBackup) validateInventories(formats strfmt.Registry) error {
	if swag.IsZero(m.Inventories) { // not required
		return nil
	}

	for i := 0; i < len(m.Inventories); i++ {
		if swag.IsZero(m.Inventories[i]) { // not required
			continue
		}

		if m.Inventories[i] != nil {
			if err := m.Inventories[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("inventories" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("inventories" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProjectBackup) validateKeys(formats strfmt.Registry) error {
	if swag.IsZero(m.Keys) { // not required
		return nil
	}

	for i := 0; i < len(m.Keys); i++ {
		if swag.IsZero(m.Keys[i]) { // not required
			continue
		}

		if m.Keys[i] != nil {
			if err := m.Keys[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("keys" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("keys" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProjectBackup) validateMeta(formats strfmt.Registry) error {
	if swag.IsZero(m.Meta) { // not required
		return nil
	}

	if m.Meta != nil {
		if err := m.Meta.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("meta")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("meta")
			}
			return err
		}
	}

	return nil
}

func (m *ProjectBackup) validateRepositories(formats strfmt.Registry) error {
	if swag.IsZero(m.Repositories) { // not required
		return nil
	}

	for i := 0; i < len(m.Repositories); i++ {
		if swag.IsZero(m.Repositories[i]) { // not required
			continue
		}

		if m.Repositories[i] != nil {
			if err := m.Repositories[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("repositories" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("repositories" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProjectBackup) validateTemplates(formats strfmt.Registry) error {
	if swag.IsZero(m.Templates) { // not required
		return nil
	}

	for i := 0; i < len(m.Templates); i++ {
		if swag.IsZero(m.Templates[i]) { // not required
			continue
		}

		if m.Templates[i] != nil {
			if err := m.Templates[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("templates" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("templates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProjectBackup) validateViews(formats strfmt.Registry) error {
	if swag.IsZero(m.Views) { // not required
		return nil
	}

	for i := 0; i < len(m.Views); i++ {
		if swag.IsZero(m.Views[i]) { // not required
			continue
		}

		if m.Views[i] != nil {
			if err := m.Views[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("views" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("views" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this project backup based on the context it is used
func (m *ProjectBackup) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEnvironments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInventories(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateKeys(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMeta(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRepositories(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTemplates(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateViews(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProjectBackup) contextValidateEnvironments(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Environments); i++ {

		if m.Environments[i] != nil {

			if swag.IsZero(m.Environments[i]) { // not required
				return nil
			}

			if err := m.Environments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("environments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("environments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProjectBackup) contextValidateInventories(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Inventories); i++ {

		if m.Inventories[i] != nil {

			if swag.IsZero(m.Inventories[i]) { // not required
				return nil
			}

			if err := m.Inventories[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("inventories" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("inventories" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProjectBackup) contextValidateKeys(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Keys); i++ {

		if m.Keys[i] != nil {

			if swag.IsZero(m.Keys[i]) { // not required
				return nil
			}

			if err := m.Keys[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("keys" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("keys" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProjectBackup) contextValidateMeta(ctx context.Context, formats strfmt.Registry) error {

	if m.Meta != nil {

		if swag.IsZero(m.Meta) { // not required
			return nil
		}

		if err := m.Meta.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("meta")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("meta")
			}
			return err
		}
	}

	return nil
}

func (m *ProjectBackup) contextValidateRepositories(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Repositories); i++ {

		if m.Repositories[i] != nil {

			if swag.IsZero(m.Repositories[i]) { // not required
				return nil
			}

			if err := m.Repositories[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("repositories" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("repositories" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProjectBackup) contextValidateTemplates(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Templates); i++ {

		if m.Templates[i] != nil {

			if swag.IsZero(m.Templates[i]) { // not required
				return nil
			}

			if err := m.Templates[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("templates" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("templates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ProjectBackup) contextValidateViews(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Views); i++ {

		if m.Views[i] != nil {

			if swag.IsZero(m.Views[i]) { // not required
				return nil
			}

			if err := m.Views[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("views" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("views" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ProjectBackup) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProjectBackup) UnmarshalBinary(b []byte) error {
	var res ProjectBackup
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ProjectBackupEnvironmentsItems0 project backup environments items0
//
// swagger:model ProjectBackupEnvironmentsItems0
type ProjectBackupEnvironmentsItems0 struct {

	// env
	Env string `json:"env,omitempty"`

	// json
	JSON string `json:"json,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// password
	Password string `json:"password,omitempty"`
}

// Validate validates this project backup environments items0
func (m *ProjectBackupEnvironmentsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this project backup environments items0 based on context it is used
func (m *ProjectBackupEnvironmentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ProjectBackupEnvironmentsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProjectBackupEnvironmentsItems0) UnmarshalBinary(b []byte) error {
	var res ProjectBackupEnvironmentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ProjectBackupInventoriesItems0 project backup inventories items0
//
// swagger:model ProjectBackupInventoriesItems0
type ProjectBackupInventoriesItems0 struct {

	// become key
	BecomeKey string `json:"become_key,omitempty"`

	// inventory
	Inventory string `json:"inventory,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// ssh key
	SSHKey string `json:"ssh_key,omitempty"`

	// type
	// Enum: ["static","static-yaml","file"]
	Type string `json:"type,omitempty"`
}

// Validate validates this project backup inventories items0
func (m *ProjectBackupInventoriesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var projectBackupInventoriesItems0TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["static","static-yaml","file"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		projectBackupInventoriesItems0TypeTypePropEnum = append(projectBackupInventoriesItems0TypeTypePropEnum, v)
	}
}

const (

	// ProjectBackupInventoriesItems0TypeStatic captures enum value "static"
	ProjectBackupInventoriesItems0TypeStatic string = "static"

	// ProjectBackupInventoriesItems0TypeStaticDashYaml captures enum value "static-yaml"
	ProjectBackupInventoriesItems0TypeStaticDashYaml string = "static-yaml"

	// ProjectBackupInventoriesItems0TypeFile captures enum value "file"
	ProjectBackupInventoriesItems0TypeFile string = "file"
)

// prop value enum
func (m *ProjectBackupInventoriesItems0) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, projectBackupInventoriesItems0TypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ProjectBackupInventoriesItems0) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this project backup inventories items0 based on context it is used
func (m *ProjectBackupInventoriesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ProjectBackupInventoriesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProjectBackupInventoriesItems0) UnmarshalBinary(b []byte) error {
	var res ProjectBackupInventoriesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ProjectBackupKeysItems0 project backup keys items0
//
// swagger:model ProjectBackupKeysItems0
type ProjectBackupKeysItems0 struct {

	// name
	Name string `json:"name,omitempty"`

	// type
	// Enum: ["ssh","login_password","none"]
	Type string `json:"type,omitempty"`
}

// Validate validates this project backup keys items0
func (m *ProjectBackupKeysItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var projectBackupKeysItems0TypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ssh","login_password","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		projectBackupKeysItems0TypeTypePropEnum = append(projectBackupKeysItems0TypeTypePropEnum, v)
	}
}

const (

	// ProjectBackupKeysItems0TypeSSH captures enum value "ssh"
	ProjectBackupKeysItems0TypeSSH string = "ssh"

	// ProjectBackupKeysItems0TypeLoginPassword captures enum value "login_password"
	ProjectBackupKeysItems0TypeLoginPassword string = "login_password"

	// ProjectBackupKeysItems0TypeNone captures enum value "none"
	ProjectBackupKeysItems0TypeNone string = "none"
)

// prop value enum
func (m *ProjectBackupKeysItems0) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, projectBackupKeysItems0TypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ProjectBackupKeysItems0) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this project backup keys items0 based on context it is used
func (m *ProjectBackupKeysItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ProjectBackupKeysItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProjectBackupKeysItems0) UnmarshalBinary(b []byte) error {
	var res ProjectBackupKeysItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ProjectBackupMeta project backup meta
//
// swagger:model ProjectBackupMeta
type ProjectBackupMeta struct {

	// alert
	Alert bool `json:"alert,omitempty"`

	// alert chat
	AlertChat string `json:"alert_chat,omitempty"`

	// max parallel tasks
	// Minimum: 0
	MaxParallelTasks *int64 `json:"max_parallel_tasks,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// type
	Type string `json:"type,omitempty"`
}

// Validate validates this project backup meta
func (m *ProjectBackupMeta) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMaxParallelTasks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProjectBackupMeta) validateMaxParallelTasks(formats strfmt.Registry) error {
	if swag.IsZero(m.MaxParallelTasks) { // not required
		return nil
	}

	if err := validate.MinimumInt("meta"+"."+"max_parallel_tasks", "body", *m.MaxParallelTasks, 0, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this project backup meta based on context it is used
func (m *ProjectBackupMeta) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ProjectBackupMeta) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProjectBackupMeta) UnmarshalBinary(b []byte) error {
	var res ProjectBackupMeta
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ProjectBackupRepositoriesItems0 project backup repositories items0
//
// swagger:model ProjectBackupRepositoriesItems0
type ProjectBackupRepositoriesItems0 struct {

	// git branch
	GitBranch string `json:"git_branch,omitempty"`

	// git url
	GitURL string `json:"git_url,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// ssh key
	SSHKey string `json:"ssh_key,omitempty"`
}

// Validate validates this project backup repositories items0
func (m *ProjectBackupRepositoriesItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this project backup repositories items0 based on context it is used
func (m *ProjectBackupRepositoriesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ProjectBackupRepositoriesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProjectBackupRepositoriesItems0) UnmarshalBinary(b []byte) error {
	var res ProjectBackupRepositoriesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ProjectBackupTemplatesItems0 project backup templates items0
//
// swagger:model ProjectBackupTemplatesItems0
type ProjectBackupTemplatesItems0 struct {

	// allow override args in task
	AllowOverrideArgsInTask bool `json:"allow_override_args_in_task,omitempty"`

	// arguments
	Arguments string `json:"arguments,omitempty"`

	// autorun
	Autorun bool `json:"autorun,omitempty"`

	// build template
	BuildTemplate string `json:"build_template,omitempty"`

	// cron
	Cron string `json:"cron,omitempty"`

	// description
	Description string `json:"description,omitempty"`

	// environment
	Environment string `json:"environment,omitempty"`

	// inventory
	Inventory string `json:"inventory,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// playbook
	Playbook string `json:"playbook,omitempty"`

	// repository
	Repository string `json:"repository,omitempty"`

	// start version
	StartVersion string `json:"start_version,omitempty"`

	// suppress success alerts
	SuppressSuccessAlerts bool `json:"suppress_success_alerts,omitempty"`

	// survey vars
	SurveyVars string `json:"survey_vars,omitempty"`

	// type
	Type string `json:"type,omitempty"`

	// vault key
	VaultKey string `json:"vault_key,omitempty"`

	// view
	View string `json:"view,omitempty"`
}

// Validate validates this project backup templates items0
func (m *ProjectBackupTemplatesItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this project backup templates items0 based on context it is used
func (m *ProjectBackupTemplatesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ProjectBackupTemplatesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProjectBackupTemplatesItems0) UnmarshalBinary(b []byte) error {
	var res ProjectBackupTemplatesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ProjectBackupViewsItems0 project backup views items0
//
// swagger:model ProjectBackupViewsItems0
type ProjectBackupViewsItems0 struct {

	// name
	Name string `json:"name,omitempty"`

	// position
	// Minimum: 0
	Position *int64 `json:"position,omitempty"`
}

// Validate validates this project backup views items0
func (m *ProjectBackupViewsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePosition(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProjectBackupViewsItems0) validatePosition(formats strfmt.Registry) error {
	if swag.IsZero(m.Position) { // not required
		return nil
	}

	if err := validate.MinimumInt("position", "body", *m.Position, 0, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this project backup views items0 based on context it is used
func (m *ProjectBackupViewsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ProjectBackupViewsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ProjectBackupViewsItems0) UnmarshalBinary(b []byte) error {
	var res ProjectBackupViewsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
